---
title: "CSharp效率研究"
date: 2023-12-10
draft: false
---


本文主要是记录研究各种C# 结构下的运行效率对比。

# Linq效率测试

C#拥有Linq语句，类似与数据库操作语法。使用其中语法可以快速实现一些功能，例如排序。这里主要测试对于排序与普通的Sort之间的区别。并总结，相关也可以参看C#语言思考部分。

对于Linq来说，有两点：

* 其是一个延迟结构，即只有调用的时候才会去执行排序操作。
* 其每次会产生一个新的容器列表。

而使用Sort接口则是原位置排序，所以对比操作如下：

```csharp
public void TestLinqSort()
{
    // Linq对比 会返回一个新序列集合
    test_list.OrderBy((num) => num).ToList();
    // Sort对比 原位置排序 要拷贝一份
    var new_list = new List<int>(test_list);
    new_list.Sort((n1, n2) => n1.CompareTo(n2));
}
```

| 方式说明 | 时间花费(ms)     | 时间花费(ms)     |
| -------- | ---------------- | ---------------- |
|          | 数组个数：$10^3$ | 数组个数：$10^7$ |
|          | 运行次数：$10^4$ | 运行次数：1      |
| Linq     | 4087             | 14350            |
| Sort     | 1691             | 3934             |

可以看到Linq耗时还是比较高的，比copy创建List+Sort还要慢。我认为这是因为Linq不仅创建目标数组，还创建了一个中间泛型数组来做比较，称之为Sort数组。这也可以通过其接口只用一个返回Int的函数来看出，这一步相当于一部映射操作，即把对象都映射到整数上，使用整数的序关系来排序。另一方面是即便是排序操作，对于Linq来说，底层也是只有当遍历的时候才进行操作，这个可以看源码是通过一个partial quick sort来操作的。




# 类型转化测试

C# 作为静态类型语言。在代码层一定要带上类型结构，这就伴随着必不可少的类型转换问题。这里主要是测试一下 强转与as is等效率直接的差异而已。

运行次数：$10^9$
| 方式说明 | 时间花费(ms) |
| -------- | ------------ |
| 强转     | 2601         |
| As转换   | 3065         |

带If判断的操作。

运行次数：$10^9$
| 方式说明 | 时间花费(ms) |
| -------- | ------------ |
| as + if  | 4526         |
| is + if  | 4319         |


可以看到效率差异其实都不是很大。只是强转如果类型不同会失败，但是as会返回null。而对于原本就是null类型，强转与as都会给出null。实际对于架构来说，架构内部结构会要求传入的都是程序员知道类型来控制。所以强转也无大问题。

# Diction遍历测试

Dictionary遍历主要有两个方面，每次都是遍历Dictionary获取对应的KeyPair然后获取对应的值。还有一个是生成Key或者Value的迭代器来操作。这里主要对比两个方式的效率差异。


运行次数：$10^9$
| 方式说明      | 时间花费(ms) |
| ------------- | ------------ |
| foreach       | 2482         |
| foreach +Keys | 1946         |


可以发现单纯的遍历Keys或者Values会要快一些。这是因为虽然Keys或者Values方法虽然会生成一个中间结构来作为迭代器。但是对于遍历Dictionary实际上，会对每一个KeyValue对生成一个KeyPair对象来封装，所以会慢一点。可以参看底层数据结构部分。